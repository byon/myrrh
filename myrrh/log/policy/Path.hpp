// Copyright 2007 Marko Raatikainen.
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

/**
 * This file contains declaration of class myrrh::log::policy::Path
 *
 * $Id: Path.hpp 355 2007-09-17 18:48:35Z byon $
 */

#ifndef MYRRH_LOG_POLICY_PATH_HPP_INCLUDED
#define MYRRH_LOG_POLICY_PATH_HPP_INCLUDED

#include "boost/shared_ptr.hpp"

#include <string>
#include <vector>

namespace boost { namespace filesystem { class path; } }

namespace myrrh
{

// Forward declarations
namespace file { class ExpressionMatcher; }

namespace log
{

namespace policy
{

// Forward declarations
class PartSum;
class PathPart;
class RestrictionStore;

typedef std::vector<boost::shared_ptr<PathPart> > PartStore;

/**
 * The Path class is used to contain the rules needed to construct names for
 * new files and to match old file names. A Path object is constructed from
 * one or several PathPart objects. Each of the PathPart objects are
 * responsible for one small part in the file path. They can be hard-coded
 * strings, running integers, timestamps, etc.
 *
 * Examples on how to construct new Path objects can be found from
 * src/log/policy/Examples.cpp.
 *
 * New file names can be generated by calling member method Generate( ).
 *
 * For purposes of comparing existing file names to the rules of a Path object,
 * @see Path::Entity.
 *
 * @todo Add tests for copy construction
 */
class Path
{
public:

    class Entity;

    typedef std::vector<Entity> EntityStore;
    typedef EntityStore::const_iterator EntityIterator;

    /**
     * Exception class, which is thrown when errors occur during Path creation
     */
    class Error : public std::runtime_error
    {
    public:
        explicit Error(const std::string &what);
    };

    /**
     * Constructor.
     * @param parentPath Parent path that will be used as a starting place for
     *                   all paths generated by the Path object. If empty path
     *                   is given (as is the default), the paths will be
     *                   constructed from the running directory.
     */
    explicit Path(const boost::filesystem::path &parentPath);
    Path( );

    /**
     * Returns the parent path. May be empty.
     */
    const boost::filesystem::path &ParentPath( ) const;

    /**
     * Generates a new file path from the contained path parts
     * @return A new file path that can be used to open a brand new file. It is
     *         not guaranteened that the path is not already in use.
     */
    boost::filesystem::path Generate( );

    /**
     * Adds new path parts to the path. Note that the method is not planned to
     * be used straight by the user. Instead the user is expected to add
     * objects of PathPart subclasses, which are then implicitly collected
     * to a new PartSum object.
     * @param parts A storage of the new path parts
     * @returns reference to *this
     */
    Path &operator+=(const PartSum &parts);

    /**
     * Adds a new hard coded path part to the path. If the new part contains
     * path separators, the part is separated into distict path entities.
     * @param path The new path part to be added.
     * @returns reference to *this
     */
    Path &operator+=(const std::string &path);

    /**
     * Returns an iterator that points to the first entity in the path.
     */
    // What is this really used for?
    EntityIterator BeginEntity( ) const;

    /**
     * Returns an iterator that marks the end of the entities of the path. Note
     * that it is always illegal to dereference this iterator. It must only be
     * used for checking of end of iteration.
     */
    // What is this really used for?
    EntityIterator EndEntity( ) const;

    /**
     * The entities of the path may contain restrictions for the path. Those
     * restrictions can be added to a restriction store via this method. An
     * example is myrrh::log::policy::Date, which has restriction of type
     * myrrh::log::policy::DateRestriction.
     * @param store The store into which the new restriction will be appended
     */
    void AppendRestrictions(RestrictionStore &store) const;

private:

    class Implementation;

    boost::shared_ptr<Implementation> implementation_;
};

}
}
}

#endif
